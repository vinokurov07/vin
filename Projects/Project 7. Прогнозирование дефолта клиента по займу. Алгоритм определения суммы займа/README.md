# PROJECT-7. Прогнозирование вероятности дефолта клиента по займу на основании кредитной истории. Создание алгоритма определения суммы займа исходя из предсказания модели и анализа цифрового профиля клиента.

## Оглавление  
[1. Описание проекта](README.md#Описание-проекта)  
[2. Краткая информация о данных](README.md#Краткая-информация-о-данных)  
[3. Этапы работы над проектом](README.md#Этапы-работы-над-проектом)  
[4. Результаты](README.md#Результаты)    
[5. Выводы](README.md#Выводы) 

### Описание проекта  

Микрофинансовая организация выдает займы сроком от 16 до 30 дней в размере от 3 до 30 тыс. Решение о сумме выдачи принимается на основе кредитной истории клиента и зависит от вероятности клиента уйти в дефолт. Под дефолтом понимается просрочка первого платежа более чем на 30 дней - FPD30 (first payment default). Так, например, если клиент взял займ сроком на 20 дней, он обязан внести платеж на любую сумму в течение 50 дней, чтобы не уйти в дефолт. Для оценки вероятности дефолта используется модель, обученная на кредитной истории клиента.

**Цель**: сформировать решение по выдаче клиенту микрозайма на основе его кредитной истории.

:arrow_up:[к оглавлению](README.md#Оглавление)


### Краткая информация о данных

Имеются две таблицы. Таблица с займами loans имеет размер 700083 rows × 7 columns.
Таблица с платежами по займам payments имеет размер 1070084 rows × 4 columns.

**Описание набора данных**:
1. loans.csv - займы клиентов:
    - client_id - идентификатор клиента;
    - loan_id - идентификатор займа;
    - loan_period - период, а который выдавался займ.
    - loan_amount_start - запрашиваемая сумма.
    - loan_amount - выданная сумма.
    - date_issue - дата выдачи займа.
    - date_close - дата закрытия займа.
2. payments.csv - платежи по займам:
    - loan_id - идентификатор займа;
    - pay_type - тип платежа (рекуррентный или не рекуррентный);
    - date_pay - дата платежа;
    - amount - сумма.

 
:arrow_up:[к оглавлению](README.md#Оглавление)


### Этапы работы над проектом  


**Часть 1. Исследовательский анализ:**
1. Провести разведочный анализ данных.
2. Сформировать две выборки:
    - все займы клиентов, исключая последние (кредитная история);
    - последние займы клиентов (обучающая выборка).
3. Для обучающей выборки сформировать целевую переменную.
4. Сгенерировать и отобрать признаки на кредитной истории.

**Часть 2. Обучение и валидация модели:**
1. Обучить модель логистической регрессии и градиентного бустинга на обучающей выборке.
По желанию, можно обучить модели с иной архитектурой.
2. Выбрать наилучшую модель и обосновать свое решение.
3. Для выбранной модели провести анализ наиболее информативных признаков.

**Часть 3. Формирование выдачи\*:**
1. Используя предсказания выбранной модели, предложить алгоритм формирования суммы выдачи для клиентов из обучающей выборки. Дополнительно, вместе с предсказанием выбранной модели, можно использовать сгенерированные признаки для формирования суммы выдачи.

:arrow_up:[к оглавлению](README.md#Оглавление)

### Результаты
[Весь проект выполнен в ноутбуке](</Projects/Project 7/Project 7.ipynb>)

:arrow_up:[к оглавлению](README.md#Оглавление)

### Выводы:  

Итак, в ходе работы были выполнены все этапы проекта.

**Часть 1. Исследовательский анализ:**

1.1. Разведывательный анализ данных (EDA).

Был проведен анализ данных. Данные были очищены от дубликатов, пропусков и логических выбросов.

1.2. Сформировать две выборки.

По сути наша конечная цель - это получить признаки поведения клиента (цифровой профиль). Исходя из имеющихся данных было выполнено два уровня агрегации, но на этом этапе выполнен первый уровень агрегации. 
**На первом уровне** в виде неких признаков требовалось получить информацию из таблицы с платежами для каждого займа(агрегировав по конкретному займу). После этого таблицы были объединены по ключу loan_id и каждый займ стал содержать характеристики этого займа (сумма, кол-во и средний платеж по займу,  первый и последний платеж по займу, кол-во уник. займов, кол-во реккурентных платежей).
В объединенной таблице проведен Feature Engineering, созданы новые признаки: сколько в днях длился займ, доля погашения займа, доля рекуррентных платежей, количество дней между первым платежом и датой займа, период платежей (в днях).
После этого забегая вперед была сформирована целевая переменная и сформированы обучающая выборка (последние займы клиентов) и кредитная история (все займы клиентов кроме последнего).

1.3. Для обучающей выборки сформировать целевую переменную.

Целевая переменная была сформирована из логики: 
- Есть платежи, но первый платеж опоздал - дефолт
- Нет платежей и срок платежа уже прошел на дату анализа - дефолт
- Иначе не дефолт

1.4. Сгенерировать и отобрать признаки на кредитной истории.

Был выполнен **второй уровень агрегации** по клиенту и сформированы новые признаки, отображающие цифровой профиль клиента. Признаки были проверены на мультиколлениарность и отобраны.  В результате обучающая выборка была дополнена цифровым профилем клиента, сформированным на кредитной истории. Для дальнейшего обучения моделей из обучающей выборки удалены признаки, которые мы не можем знать для новых клиентов. В результате таблица для обучения моделей имеет следующий признаки:
    - **client_id** - идентификатор клиента  
    - **default** - целевая переменная  
    - **prev_loans_count** - количество предыдущих займов  
    - **avg_loan_amount** -средняя сумма займов  
    -  **total_loan_amount** - общая сумма всех займов  
    - **avg_loan_period** - средний период займа  
    - **default_rate_history** - доля дефолтов в истории  
    - **avg_payment_count** - среднее количество платежей по займам  
    - **avg_paid_ratio** - средняя доля погашения займов  
    - **avg_pay_type_ratio** - средняя доля рекуррентных платежей    
    - **avg_days_to_first_payment** - среднее количество дней до первого платежа    
    - **avg_payment_period_days** - средняя продолжительность периода платежей   
    - **max_loan_time** - максимальное время займа  
    - **loan_amount_start** - запрашиваемая сумма  
    - **loan_amount** - выданная сумма  
    - **loan_period** - период, а который выдавался займ.

После этого было проверено распределение новых признаков, наличие выбросов. По ряду признаков очень много выбросов, они имеют четко выраженую правостороннюю асимметрию распределения. Основное распределение данных сконцентрировано в небольшой области, а дальше имеем длинный хвост значений. 
Забегая вперед я обучил модели на различных вариантах:
- оставил как есть
- убрал выбросы по методу Тьюки(пробовал разные коэффициенты умножения на межквартильный размах)
- пробовал по методу z-отклонений (но данные не распределены нормально, поэтому не очень эффективно)
- задал верние и нижние границы как lower_bound = Q1 - (1.5 * IQR) и upper_bound = Q3 + (1.5 * IQR) и все что ниже/выше этих значений заменил на эти значения
- доработал предыдущий способ и внес какую-то логику.
В общем если выучить модель на признаках как есть сейчас, получаем наилучшие метрики. Любое ограничение выборки путем удаления выбросов делает модель хуже. Видимо в критические значения параметров попадают дефолтные клиенты, а мы их удаляем и делаем беднее и без того маленькую долю миноритарного класса, что важно для модели (а это не выбросы, а особые случаи кредитного поведения).

**Часть 2. Обучение и валидация модели:**

*2.1. Обучить модель логистической регрессии и градиентного бустинга на обучающей выборке.*
По желанию, можно обучить модели с иной архитектурой.*

Перед обучением стоит отметить важную делать - мы имеем дело с неравномерным распределением выборки по целевой переменной: доля дефолтов - 18%, недефолтов - 82%.
При разбиении выборки на тест/трейн, чтоб целевая переменная попала в обе выборки в одинаковом соотношении, используем разбиение со стратификацией.
Также проведена стандартизация данных перед обучением.

Были построены и прошли валидацию следующие модели:
1) Логистическая регрессия
2) Градиентный бустинг
3) Случайный лес
4) Стекинг уже построенных ранее моделей, в качестве метамодели - логистическая регрессия.

Для моделей были подобраны оптимальные гиперпараметры с помощью метода RandomizedSearchCV. 
С помощью этого метода помимо оптимальных гиперпараметорв также получили автоматическое построение новой модели на всем обучающем наборе данных, используя параметры, которые дают наилучшее значение точности при кросс-валидации на 3 фолдах.  
Так как классы несбалансированы, использовался кросс-валидатор StratifiedKFold. 

В условиях неравномерного распределения целевой переменной модели были обучены с учетом взвешивания классов миноритоной и мажоритарной выборки.

*2.2. Выбрать наилучшую модель и обосновать свое решение*

Для каждой модели посчитаны метрики: Accuracy, Pprecision, Recall, F1-Score, ROC-AUC, Gini, PR-AUC.

При выборе будем ориентироаться на метрику f1-score, как комплексно отражающую precision и recall, а также PR-AUC, как площать под кривой precision-recall.    
В условиях несбалансированно распределенной целевой переменной не будем ориентироваться на высокий показатель метрики Accuracy, т.к. она просто хорошо предсказывает недефолтных клиентов (хотя после взвешивания классов метрика стала объективнее).
В нашем случае лучшие метрики качества показывает модель **градиентого бустинга**.

Итак, что можно сказать по ней:
* **Recall**   
Подобрав веса классов удалось достичь хороших резудьтатов по выявлению дефолтных клиентов. Recall = 0.72. О чем это говорит? Из всех клиентов модель верно определяет 72%. Хороший результат. 
* **Precision**   
Сбалансировав веса классов мы повысили охват, но точность снизилась до 0.34. Это закономерный процесс, стало больше значений, из которых нужно выбирать True Positive, но по сути когда модель говорит "дефолт", она права только в 34% случаев, а 66% добросоветсных клиентов получают отказ. Попробуем исправить это изменением порога вероятности отнесения к классу 1.
* **F1-score**   
 F1-score = 0.46, что говорит о хорошем что балансе между Precision и Recall. 
* **PR-AUC**   
В условиях несбалансированного распределения эта метрика более актуальна, т.к. в отличие от F1-score учитвает все возможные пороги вероятности (интеграл под всей PR-кривой). Знчение = 0,43 говорит о том, что в целом модель имеет умеренное, но стабильное качество обнаружения дефолтов при любых порогах.
* **AUC-ROC и Gini** 
Метрики ROC-AUC = 0.77 и Gini: 0.54 говорят о том, модель хорошо ранжирует клиентов по риску, т.е. модель можно использовать для сортировки клиентов на группы риска и использовать дифференцированный подход при выдаче займов (если взять случайного покупателя и случайного непокупателя, то в 77% случаев модель присвоит покупателю более высокую вероятность, чем непокупателю). 

Кроме того, для модели градиентного бустинга проведен подбор оптимального порога вероятности с помощью PR-кривой, а также сэмплирование обучающей выборки и обучение на ней. Взвешивание классов дало лучший результат.
При пороге вероятности 0.58 F1-score даже немного вырос, охват упал (мы стали определять только 58% дефолтных клиентов), но зато делаем это более точно (делаем меньше ложных отказов). Оставлять такой порог или нет зависит от задачи, что главное, а что вторичное. Если цель - находить дефолты и минимизировать потери денег - то первый вариант модели лучше, а если важнее максимизировать прибыль, меньше отказывая хорошим клиентам, то этот вариант модели будет лучше.

*2.3. Для выбранной модели провести анализ наиболее информативных признаков.*

Проведен анализ наиболее важных признаков для модели. Для каждого признка на основе анализа срофмированы пороги значений по уровню риска дефолта клиента.

* avg_days_to_first_payment - среднее количество дней до первого платежа
    avg_days_to_first_payment <= 11 - низкий риск
    avg_days_to_first_payment <= 16 - средний
    avg_days_to_first_payment <= 23 - повышенный
    avg_days_to_first_payment > 23  - высокий

* loan_amount_start - запрашиваемая сумма
    loan_amount_start <= 5000  - низкий риск
    loan_amount_start <= 16000 - средний
    loan_amount_start <= 22000 - повышенный
    loan_amount_start > 22000  - высокий

* total_loan_amount - общая сумма всех займов
    total_loan_amount >= 50000 - низкий риск
    total_loan_amount >= 25000 - средний
    total_loan_amount >= 15000 - повышенный
    total_loan_amount < 15000  - высокий
 
* avg_paid_ratio -  средняя доля погашения займов
    1.0 <= avg_paid_ratio <= 1.25 - низкий риск
    1.25 < avg_paid_ratio <= 1.5      - средний
    (1.5 < avg_paid_ratio <= 1.9) или (0.5 < avg_paid_ratio < 1.0) - повышенный
    avg_paid_ratio < 0.5 или avg_paid_ratio > 1.9 - высокий

* max_loan_time - максимальное время займа (разница между датой зактырия и открытия).
    max_time <= 30 - низкий риск
    max_time <= 60 - средний
    max_time <= 90 - повышенный
    max_time > 90  - высокий

**Часть 3. Формирование выдачи\*:**
*Используя предсказания выбранной модели, предложить алгоритм формирования суммы выдачи для клиентов из обучающей выборки. Дополнительно, вместе с предсказанием выбранной модели, можно использовать сгенерированные признаки для формирования суммы выдачи.*

Я проанализировал 5 ключевых признаков и для каждого составил ранжирование по уровню риска. Теперь нужно получить некий коэффициент риска клиента по этим признакам.  
Также мы имеем модель, которая предсказывает вероятность дефолта. Нужно использовать эту информацию и определить некий коэффициент риска клиента на основании предсказания модели.  
Потом на основании этих коэффициентов определим риск-профиль клиента (как обобщающий коэффициент) и учитывая его и ту сумму, которую запрашивает клиент посчитаем одобренную к выдаче сумму.   
Т.к. нам нужно это сделать это для каждого клиента, нужно сделать это в виде функции, чтоб применить ко всей обучающей выборке.

В общем:
1. Построена функция, которая определяет коэффициент риска дефолта клиента на основании анализа ключевых признаков.

    У нас уже есть анализ клиента по 5 ключевым признакам и готовые группы по уровню риска для каждого признака. Нужно просто обернуть это в код и в функцию, чтоб потом применить к каждому клиенту в обучающей выборке. Будем присваивать риск-баллы от 1 до 4 по каждому признаку. Чем больше риск - тем больше баллов. В конце полученную сумму риск-баллов переведем в коэффициент риска от 0 до 1.
    Т.е. функция принимает на вход строку таблицы, в соответствии со значением каждого ключевого признака считает риск-баллы и в конце переводит это в коэффициент риска на основании признаков и возвращает его.
    Это будет один из двух коэффициентов риска - коэффициентов риска на основании признаков risk_koef_feature.

2. Сделать функцию, которая определяет коэффициент риска дефолта клиента на основании предсказания модели

    Второй коэффициент риска - коэффициентов риска на основании предсказания модели. Соответственно также сделаем функцию, она на основании предсказания вероятности отношения клиента к классу 1  присвоит клиенту коэффициент риска по предсказанию модели risk_koef_model.
    Функция принимает на вход строку таблицы и на основании вероятности отношения клиента к классу дефолт возвращает коэффициент риска.

3. Сделать функцию, которая на основании результатов предыдущих функий определет размер выдаваемого займа.

    Два коэффициента риска есть, на оновании них определим риск-профиль (как среднеарифметическое 2 коэффициентов, можно одному коэффициенту задавать больший вес, можно умножать на них поочередно, т.е. функция позволит гибко настраивать этот момент).
    Запрашиваемую клиентом сумму умножим на коэф. риск-профиль.
    Функция принимает на вход строку таблицы, считает риск-профиль, на его основании рассчитывает одобренную сумму, проверяет на допустимые лимиты и возвращает эту сумму

**Вывод:**

Все этапы задачи выполнены, сформирован цифровой профиль клиента из признаков, сгененерированных и отобранных на кредитной истории. Построена и отобрана лучшая модель для оценки  дефолта клиента по займу. Создан алгоритм определения суммы займа индивидуально для каждого клиента на основании предсказания модели и основных признаков цифрового профиля.

:arrow_up:[к оглавлению](README.md#Оглавление)

